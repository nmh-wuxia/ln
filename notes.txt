Light Novel Translation Design
TODO:
  Add voting for patches, and accept patches based on votes.
  Basic:
    Approval + Wilson lower bound

    Compute for each candidate: upvotes u, total n. Convert to a lower
    confidence bound on true approval rate using the Wilson score interval (take
    the lower 95% bound). Accept the candidate whose lower bound is highest and
    exceeds a threshold (e.g., 0.6) and “Keep original” by a margin
    (e.g., ≥0.05), with a minimum effective sample size. This resists early
    brigades and tiny samples.
  ----
  Translation Prompts:
    ChatGPT has suggested the following pipeline for translations (rather than
    the one-shot I've used)

    Summarization -> Rolling window -> Cleanup

    So far it has suggested using small models for summarization and cleanup.

    I also haven't checked ChatGPT's performance on the rolling window vs DeepSeek.

    If I can get good performance from small or mini models on this task, that
    would lower my costs considerably.
  

Publisher
  (Note: Depends on Chapter)
  (Note: Uses R2 + DO Storage)
	publish_story (title)
		X create & store story metadata 
		X store story metadata (chapter list)
  publish_chapter (english_chapter)
		X Store the translated chapter
		X Update the story metadata (chapter list) with new chapter (title, links to render)
		Render the translated chapter to html and store render.
	publish_chapter (raw_chapter)
		Store the raw chapter
		Queue the chapter up for translation
		Retrieve the translated chapter
		Store the translated chapter
		Render the translated chapter to html and store render.
		Update the story metadata (chapter list) with new chapter (title, links to render)
Story
	list_chapters ()
		(titles, links, when_free)
Chapter
  (Note: Uses R2 + DO storage)
	X is_free (now)
		is the chapter free now?
	X update
		lock the chapter
		store the new chapter text with an incremented version
		re-render the new chapter text with an incremented version & store
		unlock the chapter
  X text (version)
    return chapter text at a given version.
User
  (Note: Depends on Stripe integration and Chapter)
  (Note: Uses DO storage)
	X has_credits()
		user.credits
	X add_credits()
		credits = payment_flow()
		user.credits += credits
	X own(chapter)
		user.owns(chapter)?
		user.has_credits(chapter.cost())? payment_flow();
		user.has_credits?
		user.credits -= chapter.cost()
		user.owns += chapter
	X owns(now, chapter)
		user.owns(chapter)?
		chapter.is_free(now)?
		false
  X payment_flow()
    (Note: mocked)
    contact stripe for payment flow
    return credits added to account

export ENDPOINT='https://lightnovel.nmhancocfin.workers.dev/rpc/chapter'
curl -X POST "$ENDPOINT" -H 'content-type: application/json' -d '{ "name": "story:chapter", "method": "init", "params": { "story_title": "story", "chapter_title": "chapter", "when_free": 0, "cost": 0, "text": "Hello" } }'

curl -X POST "$ENDPOINT" -H 'content-type: application/json' -d '{ "name": "story:chapter", "method": "text" }'

PATCH=$(node --input-type=module -e "import DMP from 'diff-match-patch'; const d=new DMP();    console.log(d.patch_toText(d.patch_make('Hello','Hello world!')))")                             

RESP=$(curl -s -X POST "$ENDPOINT" -H 'content-type: application/json' -d "$(jq -n --arg p "$PATCH" '{ name:"story:chapter", method:"add_patch", params:{ start:5, end:5, patch: $p } }')")

ID=$(echo "$RESP" | jq -r .id) 
curl -X POST "$ENDPOINT" -H 'content-type: application/json' -d "$(jq -n --arg id "$ID" '{ name:"story:chapter", method:"apply_patch", params:{ id:$id } }')" 

{"ok":true,"version":4}%                                                                               
curl -X POST "$ENDPOINT" -H 'content-type: application/json' -d '{ "name": "story:chapter", "method": "text" }'

{"result":"Hello world!"}%
